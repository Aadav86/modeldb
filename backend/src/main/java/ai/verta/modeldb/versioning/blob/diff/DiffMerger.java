package ai.verta.modeldb.versioning.blob.diff;

import ai.verta.modeldb.versioning.DiffStatusEnum;
import ai.verta.modeldb.versioning.autogenerated._public.modeldb.versioning.model.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

// TODO: handle collisions instead of just overwriting? It will be useful for mergingit
public class DiffMerger {
  public static <B, D, F, DF> Optional<F> merge(
      Optional<B> a,
      Optional<D> d,
      Function<B, Optional<F>> getterA,
      Function<D, Optional<DF>> getterD,
      Function3<Optional<F>, Optional<DF>, Optional<F>> merger) {
    if (!d.flatMap(getterD).isPresent()) return a.flatMap(getterA);
    return merger.apply(a.flatMap(getterA), d.flatMap(getterD));
  }

  public static <B, D, F extends ProtoType, DF> Optional<List<F>> mergeList(
      Optional<B> a,
      Optional<D> d,
      Function<B, Optional<List<F>>> getterA,
      Function<D, Optional<List<DF>>> getterD,
      Function<F, Optional<String>> hasherA,
      Function<DF, Optional<String>> hasherD,
      Function3<Optional<F>, Optional<DF>, Optional<F>> merger) {
    HashMap<String, HashSet<F>> mapA = new HashMap<>();
    HashMap<String, HashSet<DF>> mapD = new HashMap<>();
    a.flatMap(getterA::apply)
        .ifPresent(
            x ->
                x.forEach(
                    el ->
                        hasherA
                            .apply(el)
                            .ifPresent(h -> mapA.getOrDefault(h, new HashSet<>()).add(el))));
    d.flatMap(getterD::apply)
        .ifPresent(
            x ->
                x.forEach(
                    el ->
                        hasherD
                            .apply(el)
                            .ifPresent(h -> mapD.getOrDefault(h, new HashSet<>()).add(el))));

    HashSet<String> keys = new HashSet<>();
    keys.addAll(mapA.keySet());
    keys.addAll(mapD.keySet());

    List<F> ret =
        keys.stream()
            .flatMap(
                key -> {
                  HashSet<F> elA = mapA.get(key);
                  HashSet<DF> elD = mapD.get(key);
                  // Key collision and one element, process it
                  if (elA != null && elD != null && elA.size() == 1 && elD.size() == 1) {
                    return Stream.of(
                        merger.apply(
                            Optional.of(elA.iterator().next()),
                            Optional.of(elD.iterator().next())));
                  }

                  // Key collision and more elements, consider removal + addition
                  if (elA != null && elD != null) {
                    return Stream.concat(
                        elA.stream().map(el -> merger.apply(Optional.of(el), Optional.empty())),
                        elD.stream().map(el -> merger.apply(Optional.empty(), Optional.of(el))));
                  } else if (elA != null) {
                    return elA.stream().map(el -> merger.apply(Optional.of(el), Optional.empty()));
                  } else {
                    return elD.stream().map(el -> merger.apply(Optional.empty(), Optional.of(el)));
                  }
                })
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(Collectors.toList());
    if (ret.isEmpty()) {
      return Optional.empty();
    }
    return Optional.of(ret);
  }

  public static <T, T2> Optional<T> mergeLast(
      Optional<T> a,
      Optional<T2> d,
      Function<T2, Optional<T>> getB,
      Function<T2, Optional<DiffStatusEnumDiffStatus>> getStatus) {
    if (!d.isPresent()) return a;

    return getStatus
        .apply(d.get())
        .flatMap(
            status -> {
              if (status.Status == DiffStatusEnum.DiffStatus.ADDED
                  || status.Status == DiffStatusEnum.DiffStatus.MODIFIED) {
                return getB.apply(d.get());
              }
              if (status.Status == DiffStatusEnum.DiffStatus.DELETED) {
                return Optional.empty();
              }
              return a;
            });
  }

  public static <T> Optional<T> eitherGet(Optional<T> a, Optional<T> b) {
    if (a.isPresent()) return a;
    if (b.isPresent()) return b;
    return Optional.empty();
  }

  public static Optional<Blob> mergeBlob(Optional<Blob> a, Optional<BlobDiff> d) {
    return Utils.removeEmpty(
        new Blob()
            .setCode(merge(a, d, x -> x.Code, x -> x.Code, DiffMerger::mergeCode))
            .setConfig(merge(a, d, x -> x.Config, x -> x.Config, DiffMerger::mergeConfig))
            .setDataset(merge(a, d, x -> x.Dataset, x -> x.Dataset, DiffMerger::mergeDataset))
            .setEnvironment(
                merge(a, d, x -> x.Environment, x -> x.Environment, DiffMerger::mergeEnvironment)));
  }

  public static Optional<CodeBlob> mergeCode(Optional<CodeBlob> a, Optional<CodeDiff> d) {
    return Utils.removeEmpty(
        new CodeBlob()
            .setGit(merge(a, d, x -> x.Git, x -> x.Git, DiffMerger::mergeGitCode))
            .setNotebook(
                merge(a, d, x -> x.Notebook, x -> x.Notebook, DiffMerger::mergeNotebookCode)));
  }

  public static Optional<GitCodeBlob> mergeGitCode(
      Optional<GitCodeBlob> a, Optional<GitCodeDiff> d) {
    return Utils.removeEmpty(mergeLast(a, d, x -> x.B, x -> x.Status));
  }

  public static Optional<NotebookCodeBlob> mergeNotebookCode(
      Optional<NotebookCodeBlob> a, Optional<NotebookCodeDiff> d) {
    return Utils.removeEmpty(
        new NotebookCodeBlob()
            .setGitRepo(merge(a, d, x -> x.GitRepo, x -> x.GitRepo, DiffMerger::mergeGitCode))
            .setPath(merge(a, d, x -> x.Path, x -> x.Path, DiffMerger::mergePathDatasetComponent)));
  }

  public static Optional<ConfigBlob> mergeConfig(Optional<ConfigBlob> a, Optional<ConfigDiff> d) {
    return Utils.removeEmpty(
        new ConfigBlob()
            .setHyperparameters(
                mergeList(
                    a,
                    d,
                    x -> x.Hyperparameters,
                    x -> x.Hyperparameters,
                    x -> x.Name,
                    x -> x.Name,
                    DiffMerger::mergeHyperparameterConfig))
            .setHyperparameterSet(
                mergeList(
                    a,
                    d,
                    x -> x.HyperparameterSet,
                    x -> x.HyperparameterSet,
                    x -> x.Name,
                    x -> x.Name,
                    DiffMerger::mergeHyperparameterSetConfig)));
  }

  public static Optional<HyperparameterConfigBlob> mergeHyperparameterConfig(
      Optional<HyperparameterConfigBlob> a, Optional<HyperparameterConfigDiff> d) {
    return Utils.removeEmpty(
        new HyperparameterConfigBlob()
            .setName(eitherGet(a.flatMap(x -> x.Name), d.flatMap(x -> x.Name)))
            .setValue(mergeLast(a.flatMap(x -> x.Value), d, x -> x.B, x -> x.Status)));
  }

  public static Optional<HyperparameterSetConfigBlob> mergeHyperparameterSetConfig(
      Optional<HyperparameterSetConfigBlob> a, Optional<HyperparameterSetConfigDiff> d) {
    return Utils.removeEmpty(
        new HyperparameterSetConfigBlob()
            .setName(eitherGet(a.flatMap(x -> x.Name), d.flatMap(x -> x.Name)))
            .setContinuous(
                mergeLast(a.flatMap(x -> x.Continuous), d, x -> x.ContinuousB, x -> x.Status))
            .setDiscrete(
                mergeLast(a.flatMap(x -> x.Discrete), d, x -> x.DiscreteB, x -> x.Status)));
  }

  public static Optional<DatasetBlob> mergeDataset(
      Optional<DatasetBlob> a, Optional<DatasetDiff> d) {
    return Utils.removeEmpty(
        new DatasetBlob()
            .setPath(merge(a, d, x -> x.Path, x -> x.Path, DiffMerger::mergePathDataset))
            .setS3(merge(a, d, x -> x.S3, x -> x.S3, DiffMerger::mergeS3Dataset)));
  }

  public static Optional<PathDatasetBlob> mergePathDataset(
      Optional<PathDatasetBlob> a, Optional<PathDatasetDiff> d) {
    return Utils.removeEmpty(
        new PathDatasetBlob()
            .setComponents(
                mergeList(
                    a,
                    d,
                    x -> x.Components,
                    x -> x.Components,
                    x -> x.Path,
                    x -> x.B.flatMap(y -> y.Path),
                    DiffMerger::mergePathDatasetComponent)));
  }

  public static Optional<PathDatasetComponentBlob> mergePathDatasetComponent(
      Optional<PathDatasetComponentBlob> a, Optional<PathDatasetComponentDiff> d) {
    return Utils.removeEmpty(mergeLast(a, d, x -> x.B, x -> x.Status));
  }

  public static Optional<S3DatasetBlob> mergeS3Dataset(
      Optional<S3DatasetBlob> a, Optional<S3DatasetDiff> d) {
    return Utils.removeEmpty(
        new S3DatasetBlob()
            .setComponents(
                mergeList(
                    a,
                    d,
                    x -> x.Components,
                    x -> x.Components,
                    x -> x.Path.flatMap(y -> y.Path),
                    x -> x.Path.flatMap(y -> y.B).flatMap(y -> y.Path),
                    DiffMerger::mergeS3DatasetComponent)));
  }

  public static Optional<S3DatasetComponentBlob> mergeS3DatasetComponent(
      Optional<S3DatasetComponentBlob> a, Optional<S3DatasetComponentDiff> d) {
    return Utils.removeEmpty(
        new S3DatasetComponentBlob()
            .setPath(merge(a, d, x -> x.Path, x -> x.Path, DiffMerger::mergePathDatasetComponent)));
  }

  public static Optional<EnvironmentBlob> mergeEnvironment(
      Optional<EnvironmentBlob> a, Optional<EnvironmentDiff> d) {
    return Utils.removeEmpty(
        new EnvironmentBlob()
            .setPython(
                merge(a, d, x -> x.Python, x -> x.Python, DiffMerger::mergePythonEnvironment))
            .setDocker(
                merge(a, d, x -> x.Docker, x -> x.Docker, DiffMerger::mergeDockerEnvironment))
            .setEnvironmentVariables(
                mergeList(
                    a,
                    d,
                    x -> x.EnvironmentVariables,
                    x -> x.EnvironmentVariables,
                    x -> x.Name,
                    x -> x.Name,
                    DiffMerger::mergeEnvironmentVariables))
            .setCommandLine(
                merge(
                    a,
                    d,
                    x -> x.CommandLine,
                    x -> x.CommandLine,
                    DiffMerger::mergeCommandLineEnvironment)));
  }

  public static Optional<PythonEnvironmentBlob> mergePythonEnvironment(
      Optional<PythonEnvironmentBlob> a, Optional<PythonEnvironmentDiff> d) {
    return Utils.removeEmpty(
        new PythonEnvironmentBlob()
            .setVersion(
                merge(a, d, x -> x.Version, x -> x.Version, DiffMerger::mergeVersionEnvironment))
            .setConstraints(
                mergeList(
                    a,
                    d,
                    x -> x.Constraints,
                    x -> x.Constraints,
                    x -> x.Library,
                    x -> x.B.flatMap(y -> y.Library),
                    DiffMerger::mergePythonRequirementEnvironment))
            .setRequirements(
                mergeList(
                    a,
                    d,
                    x -> x.Requirements,
                    x -> x.Requirements,
                    x -> x.Library,
                    x -> x.B.flatMap(y -> y.Library),
                    DiffMerger::mergePythonRequirementEnvironment)));
  }

  public static Optional<VersionEnvironmentBlob> mergeVersionEnvironment(
      Optional<VersionEnvironmentBlob> a, Optional<VersionEnvironmentDiff> d) {
    return Utils.removeEmpty(mergeLast(a, d, x -> x.B, x -> x.Status));
  }

  public static Optional<List<String>> mergeCommandLineEnvironment(
      Optional<List<String>> a, Optional<CommandLineEnvironmentDiff> d) {
    return Utils.removeEmpty(mergeLast(a, d, x -> x.B, x -> x.Status));
  }

  public static Optional<PythonRequirementEnvironmentBlob> mergePythonRequirementEnvironment(
      Optional<PythonRequirementEnvironmentBlob> a, Optional<PythonRequirementEnvironmentDiff> d) {
    return Utils.removeEmpty(mergeLast(a, d, x -> x.B, x -> x.Status));
  }

  public static Optional<DockerEnvironmentBlob> mergeDockerEnvironment(
      Optional<DockerEnvironmentBlob> a, Optional<DockerEnvironmentDiff> d) {
    return Utils.removeEmpty(mergeLast(a, d, x -> x.B, x -> x.Status));
  }

  public static Optional<EnvironmentVariablesBlob> mergeEnvironmentVariables(
      Optional<EnvironmentVariablesBlob> a, Optional<EnvironmentVariablesDiff> d) {
    return Utils.removeEmpty(
        new EnvironmentVariablesBlob()
            .setName(eitherGet(a.flatMap(x -> x.Name), d.flatMap(x -> x.Name)))
            .setValue(mergeLast(a.flatMap(x -> x.Value), d, x -> x.ValueB, x -> x.Status)));
  }
}
